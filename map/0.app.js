(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[function(t,e,n){"use strict";(function(t){Object.defineProperty(e,"__esModule",{value:!0});const{isConcatSpreadable:n}=Symbol,{isArray:o}=Array,{slice:r,unshift:i,shift:a}=Array.prototype;function s(t){if(!function(t){return"object"==typeof t?null!==t:"function"==typeof t}(t))return!1;const e=t[n];return void 0!==e?Boolean(e):o(t)}function l(...t){const e=Object(this),n=[];let o=0;const l=r.call(arguments);for(i.call(l,e);l.length;){const t=a.call(l);if(s(t)){let e=0;const r=t.length;for(;e<r;e+=1,o+=1)if(e in t){const r=t[e];n[o]=r}}else n[o]=t,o+=1}return n}function c(t){return void 0===Object.getOwnPropertyDescriptor(Element.prototype,t)}(function(){if("getKey"in Proxy)return!1;const t=new Proxy([3,4],{});return 4!==[1,2].concat(t).length})()&&(Array.prototype.concat=l);const{freeze:u,seal:d,keys:f,create:h,assign:m,defineProperty:p,getPrototypeOf:g,setPrototypeOf:y,getOwnPropertyDescriptor:v,getOwnPropertyNames:b,defineProperties:w,hasOwnProperty:$}=Object,{isArray:T}=Array,{slice:E,splice:k,unshift:C,indexOf:x,push:R,map:S,join:M,forEach:A,reduce:O}=Array.prototype,{replace:P,toLowerCase:L,charCodeAt:I,slice:H}=String.prototype;function N(t){return void 0===t}function j(t){return null===t}function D(t){return!0===t}function F(t){return!1===t}function B(t){return"function"==typeof t}function q(t){return"object"==typeof t}function V(t){return"string"==typeof t}function W(t){return"number"==typeof t}const z={}.toString;function K(t){return t&&t.toString?T(t)?M.call(S.call(t,K),","):t.toString():"object"==typeof t?z.call(t):t+Y}function U(t,e){do{const n=v(t,e);if(!N(n))return n;t=g(t)}while(null!==t)}const Y="",{hasAttribute:_,getAttribute:G,setAttribute:J,setAttributeNS:Q,removeAttribute:X,removeAttributeNS:Z}=Element.prototype,tt=v(Element.prototype,"tagName").get,et=/^aria/,nt=new WeakMap,{hasOwnProperty:ot}=Object.prototype,{replace:rt,toLowerCase:it}=String.prototype;function at(t){let e=nt.get(t);return void 0===e&&(e={},nt.set(t,e)),e}function st(t){const e=rt.call(t,et,"aria-"),n=function(t,e){return{get(){const n=at(this);return ot.call(n,t)?n[t]:_.call(this,e)?G.call(this,e):null},set(n){const o=null==(r=n)?null:r+"";var r;at(this)[t]=o,null===n?X.call(this,e):J.call(this,e,n)},configurable:!0,enumerable:!0}}(t,it.call(e));Object.defineProperty(Element.prototype,t,n)}const lt=["ariaAutoComplete","ariaChecked","ariaCurrent","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaInvalid","ariaLabel","ariaLevel","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPressed","ariaReadOnly","ariaRequired","ariaSelected","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","ariaLive","ariaRelevant","ariaAtomic","ariaBusy","ariaActiveDescendant","ariaControls","ariaDescribedBy","ariaFlowTo","ariaLabelledBy","ariaOwns","ariaPosInSet","ariaSetSize","ariaColCount","ariaColIndex","ariaDetails","ariaErrorMessage","ariaKeyShortcuts","ariaModal","ariaPlaceholder","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaColSpan","role"];for(let t=0,e=lt.length;t<e;t+=1){const e=lt[t];c(e)&&st(e)}const ct={invariant(t,e){if(!t)throw new Error(`Invariant Violation: ${e}`)},isTrue(t,e){if(!t)throw new Error(`Assert Violation: ${e}`)},isFalse(t,e){if(t)throw new Error(`Assert Violation: ${e}`)},fail(t){throw new Error(t)},logError(t,e){let n=`[LWC error]: ${t}`;e&&(n=`${n}\n${function(t){const e=[];let n="",o=t;do{R.call(e,`${n}<${L.call(tt.call(o))}>`),n+="\t";const t=o.getRootNode();o=t===o||t===document?null:t instanceof ShadowRoot?t.host:t}while(!j(o));return M.call(e,"\n")}(e)}`);try{throw new Error(n)}catch(t){console.error(t)}}},ut="Symbol(x)"===Symbol("x").toString();function dt(t){return ut?Symbol(t):`$$lwc-${t}$$`}function ft(t,e,n){p(t,e,{value:n})}function ht(t,e){return t[e]}const mt=new WeakMap,pt=ut?(t,e,n)=>{let o=mt.get(t);N(o)&&(o=h(null),mt.set(t,o)),o[e]=n}:ft,gt=ut?(t,e)=>{const n=mt.get(t);return!N(n)&&n[e]}:ht,yt=["accessKey","dir","draggable","hidden","id","lang","tabIndex","title"];function vt(t){return`Using the \`${t}\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \`getBoundingClientRect\` method to obtain fractional values for the size of an element and its position relative to the viewport.`}const bt=m(h(null),{accessKey:{attribute:"accesskey"},accessKeyLabel:{readOnly:!0},className:{attribute:"class",error:"Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead."},contentEditable:{attribute:"contenteditable"},dataset:{readOnly:!0,error:"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."},dir:{attribute:"dir"},draggable:{attribute:"draggable"},dropzone:{attribute:"dropzone",readOnly:!0},hidden:{attribute:"hidden"},id:{attribute:"id"},inputMode:{attribute:"inputmode"},lang:{attribute:"lang"},slot:{attribute:"slot",error:"Using the `slot` property is an anti-pattern."},spellcheck:{attribute:"spellcheck"},style:{attribute:"style"},tabIndex:{attribute:"tabindex"},title:{attribute:"title"},translate:{attribute:"translate"},isContentEditable:{readOnly:!0},offsetHeight:{readOnly:!0,error:vt("offsetHeight")},offsetLeft:{readOnly:!0,error:vt("offsetLeft")},offsetParent:{readOnly:!0},offsetTop:{readOnly:!0,error:vt("offsetTop")},offsetWidth:{readOnly:!0,error:vt("offsetWidth")},role:{attribute:"role"}}),wt=h(null),$t=h(null);A.call(lt,t=>{const e=L.call(P.call(t,/^aria/,"aria-"));wt[e]=t,$t[t]=e}),A.call(yt,t=>{const e=L.call(t);wt[e]=t,$t[t]=e}),A.call(["accessKey","readOnly","tabIndex","bgColor","colSpan","rowSpan","contentEditable","dateTime","formAction","isMap","maxLength","useMap"],t=>{const e=L.call(t);wt[e]=t,$t[t]=e});const Tt=/-([a-z])/g;const Et=/[A-Z]/g;function kt(t){return N($t[t])&&($t[t]=P.call(t,Et,t=>"-"+t.toLowerCase())),$t[t]}let Ct,xt=null;function Rt(t,e){xt=null,Ct=void 0}function St(t,e){xt=t,Ct=e}let Mt=[];const At=32,Ot=d(h(null)),Pt=d([]),Lt=dt("ViewModel");function It(){if(0===Mt.length)throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");const t=Mt;Mt=[];for(let e=0,n=t.length;e<n;e+=1)t[e]()}function Ht(t){if(!B(t))throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");0===Mt.length&&Promise.resolve().then(It),R.call(Mt,t)}function Nt(t){return $.call(t,"__circular__")}function jt(t){if(!B(t))throw new TypeError("Circular module dependency must be a function.");return t()}const Dt=$.call(Element.prototype,"$shadowToken$");function Ft(t){const{data:{on:e}}=t;if(N(e))return;const n=t.elm,o=t.listener=function t(e){!function(t,e){const{type:n}=t,{data:{on:o}}=e,r=o&&o[n];r&&r.call(void 0,t)}(e,t.vnode)};let r;for(r in o.vnode=t,e)n.addEventListener(r,o)}var Bt={update:function(t,e){N(t.listener)?Ft(e):(e.listener=t.listener,e.listener.vnode=e)},create:Ft};const qt="http://www.w3.org/1999/xlink",Vt="http://www.w3.org/XML/1998/namespace",Wt=58;function zt(t,e){const{data:{attrs:n}}=e;if(N(n))return;let{data:{attrs:o}}=t;if(o===n)return;ct.invariant(N(o)||f(o).join(",")===f(n).join(","),"vnode.data.attrs cannot change shape.");const r=e.elm;let i;for(i in o=N(o)?Ot:o,n){const t=n[i];o[i]!==t&&(St(r,i),I.call(i,3)===Wt?r.setAttributeNS(Vt,i,t):I.call(i,5)===Wt?r.setAttributeNS(qt,i,t):j(t)?r.removeAttribute(i):r.setAttribute(i,t),Rt())}}const Kt={data:{}};var Ut={create:t=>zt(Kt,t),update:zt};const Yt=h(null);A.call(lt,t=>{const e=U(HTMLElement.prototype,t);N(e)||(Yt[t]=e)}),A.call(yt,t=>{const e=U(HTMLElement.prototype,t);N(e)||(Yt[t]=e)});const{isArray:_t}=Array,{getPrototypeOf:Gt,create:Jt,defineProperty:Qt,defineProperties:Xt,isExtensible:Zt,getOwnPropertyDescriptor:te,getOwnPropertyNames:ee,getOwnPropertySymbols:ne,preventExtensions:oe,hasOwnProperty:re}=Object,{push:ie,concat:ae,map:se}=Array.prototype,le={}.toString;function ce(t){return void 0===t}function ue(t){return"function"==typeof t}const de=new WeakMap;function fe(t,e){de.set(t,e)}const he=t=>de.get(t)||t;function me(t,e){return t.valueIsObservable(e)?t.getProxy(e):e}function pe(t,e,n){ae.call(ee(n),ne(n)).forEach(o=>{let r=te(n,o);r.configurable||(r=Re(t,r,me)),Qt(e,o,r)}),oe(e)}class ge{constructor(t,e){this.originalTarget=e,this.membrane=t}get(t,e){const{originalTarget:n,membrane:o}=this,r=n[e],{valueObserved:i}=o;return i(n,e),o.getProxy(r)}set(t,e,n){const{originalTarget:o,membrane:{valueMutated:r}}=this;return o[e]!==n?(o[e]=n,r(o,e)):"length"===e&&_t(o)&&r(o,e),!0}deleteProperty(t,e){const{originalTarget:n,membrane:{valueMutated:o}}=this;return delete n[e],o(n,e),!0}apply(t,e,n){}construct(t,e,n){}has(t,e){const{originalTarget:n,membrane:{valueObserved:o}}=this;return o(n,e),e in n}ownKeys(t){const{originalTarget:e}=this;return ae.call(ee(e),ne(e))}isExtensible(t){const e=Zt(t);if(!e)return e;const{originalTarget:n,membrane:o}=this,r=Zt(n);return r||pe(o,t,n),r}setPrototypeOf(t,e){throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${n=this.originalTarget,n&&n.toString?n.toString():"object"==typeof n?le.call(n):n+""}. Prototype of reactive objects cannot be changed.`);var n}getPrototypeOf(t){const{originalTarget:e}=this;return Gt(e)}getOwnPropertyDescriptor(t,e){const{originalTarget:n,membrane:o}=this,{valueObserved:r}=this.membrane;r(n,e);let i=te(n,e);if(ce(i))return i;const a=te(t,e);return ce(a)?((i=Re(o,i,me)).configurable||Qt(t,e,i),i):a}preventExtensions(t){const{originalTarget:e,membrane:n}=this;return pe(n,t,e),oe(e),!0}defineProperty(t,e,n){const{originalTarget:o,membrane:r}=this,{valueMutated:i}=r,{configurable:a}=n;if(re.call(n,"writable")&&!re.call(n,"value")){const t=te(o,e);n.value=t.value}return Qt(o,e,function(t){return re.call(t,"value")&&(t.value=he(t.value)),t}(n)),!1===a&&Qt(t,e,Re(r,n,me)),i(o,e),!0}}function ye(t,e){return t.valueIsObservable(e)?t.getReadOnlyProxy(e):e}class ve{constructor(t,e){this.originalTarget=e,this.membrane=t}get(t,e){const{membrane:n,originalTarget:o}=this,r=o[e],{valueObserved:i}=n;return i(o,e),n.getReadOnlyProxy(r)}set(t,e,n){{const{originalTarget:t}=this;throw new Error(`Invalid mutation: Cannot set "${e.toString()}" on "${t}". "${t}" is read-only.`)}}deleteProperty(t,e){{const{originalTarget:t}=this;throw new Error(`Invalid mutation: Cannot delete "${e.toString()}" on "${t}". "${t}" is read-only.`)}}apply(t,e,n){}construct(t,e,n){}has(t,e){const{originalTarget:n,membrane:{valueObserved:o}}=this;return o(n,e),e in n}ownKeys(t){const{originalTarget:e}=this;return ae.call(ee(e),ne(e))}setPrototypeOf(t,e){{const{originalTarget:t}=this;throw new Error(`Invalid prototype mutation: Cannot set prototype on "${t}". "${t}" prototype is read-only.`)}}getOwnPropertyDescriptor(t,e){const{originalTarget:n,membrane:o}=this,{valueObserved:r}=o;r(n,e);let i=te(n,e);if(ce(i))return i;const a=te(t,e);return ce(a)?(i=Re(o,i,ye),re.call(i,"set")&&(i.set=void 0),i.configurable||Qt(t,e,i),i):a}preventExtensions(t){{const{originalTarget:t}=this;throw new Error(`Invalid mutation: Cannot preventExtensions on ${t}". "${t} is read-only.`)}}defineProperty(t,e,n){{const{originalTarget:t}=this;throw new Error(`Invalid mutation: Cannot defineProperty "${e.toString()}" on "${t}". "${t}" is read-only.`)}}}const be={header:t=>{const e=he(t);return e&&e!==t?["object",{object:function t(e){if(_t(e))return e.map(e=>{const n=he(e);return n!==e?t(n):e});const n=Jt(Gt(e)),o=ee(e);return ae.call(o,ne(e)).reduce((n,o)=>{const r=e[o],i=he(r);return n[o]=i!==r?t(i):r,n},n)}(t)}]:null},hasBody:()=>!1,body:()=>null};function we(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==t?t:{}}function $e(t){let e=void 0;return _t(t)?e=[]:"object"==typeof t&&(e={}),e}(function(){const t=we(),e=t.devtoolsFormatters||[];ie.call(e,be),t.devtoolsFormatters=e})();const Te=Object.prototype;function Ee(t){if(null===t)return!1;if("object"!=typeof t)return!1;if(_t(t))return!0;const e=Gt(t);return e===Te||null===e||null===Gt(e)}const ke=(t,e)=>{},Ce=(t,e)=>{},xe=t=>t;function Re(t,e,n){const{set:o,get:r}=e;return re.call(e,"value")?e.value=n(t,e.value):(ce(r)||(e.get=function(){return n(t,r.call(he(this)))}),ce(o)||(e.set=function(e){o.call(he(this),t.unwrapProxy(e))})),e}const{create:Se}=Object,{splice:Me,indexOf:Ae,push:Oe}=Array.prototype,Pe=new WeakMap;function Le(t){return void 0===t}let Ie=null;function He(t,e){const n=Pe.get(t);if(!Le(n)){const t=n[e];if(!Le(t))for(let e=0,n=t.length;e<n;e+=1){t[e].notify()}}}function Ne(t,e){if(null===Ie)return;const n=Ie,o=function(t){let e=Pe.get(t);if(Le(e)){const n=Se(null);e=n,Pe.set(t,n)}return e}(t);let r=o[e];if(Le(r))r=[],o[e]=r;else if(r[0]===n)return;-1===Ae.call(r,n)&&n.link(r)}class je{constructor(t){this.listeners=[],this.callback=t}observe(t){const e=Ie;let n;Ie=this;try{t()}catch(t){n=Object(t)}finally{if(Ie=e,void 0!==n)throw n}}reset(){const{listeners:t}=this,e=t.length;if(e>0){for(let n=0;n<e;n+=1){const e=t[n],o=Ae.call(t[n],this);Me.call(e,o,1)}t.length=0}}notify(){this.callback.call(void 0,this)}link(t){Oe.call(t,this),Oe.call(this.listeners,t)}}function De(t){return t}const Fe=new class{constructor(t){if(this.valueDistortion=xe,this.valueMutated=Ce,this.valueObserved=ke,this.valueIsObservable=Ee,this.objectGraph=new WeakMap,!ce(t)){const{valueDistortion:e,valueMutated:n,valueObserved:o,valueIsObservable:r}=t;this.valueDistortion=ue(e)?e:xe,this.valueMutated=ue(n)?n:Ce,this.valueObserved=ue(o)?o:ke,this.valueIsObservable=ue(r)?r:Ee}}getProxy(t){const e=he(t),n=this.valueDistortion(e);if(this.valueIsObservable(n)){const o=this.getReactiveState(e,n);return o.readOnly===t?t:o.reactive}return n}getReadOnlyProxy(t){t=he(t);const e=this.valueDistortion(t);return this.valueIsObservable(e)?this.getReactiveState(t,e).readOnly:e}unwrapProxy(t){return he(t)}getReactiveState(t,e){const{objectGraph:n}=this;let o=n.get(e);if(o)return o;const r=this;return o={get reactive(){const n=new ge(r,e),o=new Proxy($e(e),n);return fe(o,t),Qt(this,"reactive",{value:o}),o},get readOnly(){const n=new ve(r,e),o=new Proxy($e(e),n);return fe(o,t),Qt(this,"readOnly",{value:o}),o}},n.set(e,o),o}}({valueObserved:Ne,valueMutated:He,valueDistortion:De});function Be(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`)}const qe=h(null),Ve=h(null);function We(t){let e=qe[t];return N(e)&&(e=qe[t]=function(){const e=Br(this),{getHook:n}=e;return n(e.component,t)}),e}function ze(t){let e=Ve[t];return N(e)&&(e=Ve[t]=function(e){const n=Br(this),{setHook:o}=n;e=Fe.getReadOnlyProxy(e),o(n.component,t,e)}),e}function Ke(t){return function(){const e=Br(this),{callHook:n,component:o}=e,r=o[t];return n(e.component,r,E.call(arguments))}}function Ue(t,e,n){let o;B(t)?o=class extends t{}:(y(o=function(){throw new TypeError("Illegal constructor")},t),y(o.prototype,t.prototype),p(o.prototype,"constructor",{writable:!0,configurable:!0,value:o}));const r=h(null);for(let t=0,n=e.length;t<n;t+=1){const n=e[t];r[n]={get:We(n),set:ze(n),enumerable:!0,configurable:!0}}for(let t=0,e=n.length;t<e;t+=1){const e=n[t];r[e]={value:Ke(e),writable:!0,configurable:!0}}return w(o.prototype,r),o}const Ye=Ue(HTMLElement,b(Yt),[]);function _e(t,e){return"input"===t&&("value"===e||"checked"===e)}function Ge(t,e){const n=e.data.props;if(N(n))return;const o=t.data.props;if(o===n)return;ct.invariant(N(o)||f(o).join(",")===f(n).join(","),"vnode.data.props cannot change shape.");const r=e.elm,i=ht(r,Lt),a=N(o),s=!N(i),{sel:l}=e;for(const t in n){const e=n[t];t in r||ct.fail(`Unknown public property "${t}" of element <${l}>. This is likely a typo on the corresponding attribute "${kt(t)}".`),(a||e!==(_e(l,t)?r[t]:o[t]))&&(s&&Be(i),r[t]=e)}}u(Ye),d(Ye.prototype);const Je={data:{}};var Qe={create:t=>Ge(Je,t),update:Ge};const Xe=h(null);function Ze(t){if(null==t)return Ot;t=V(t)?t:t+"";let e=Xe[t];if(e)return e;e=h(null);let n,o=0;const r=t.length;for(n=0;n<r;n++)I.call(t,n)===At&&(n>o&&(e[H.call(t,o,n)]=!0),o=n+1);return n>o&&(e[H.call(t,o,n)]=!0),Xe[t]=e,u(e),e}function tn(t,e){const{elm:n,data:{className:o}}=e,{data:{className:r}}=t;if(r===o)return;const{classList:i}=n,a=Ze(o),s=Ze(r);let l;for(l in s)N(a[l])&&i.remove(l);for(l in a)N(s[l])&&i.add(l)}const en={data:{}};var nn={create:t=>tn(en,t),update:tn};function on(t,e){const{style:n}=e.data;if(t.data.style===n)return;const o=e.elm,{style:r}=o;V(n)&&""!==n?r.cssText=n:X.call(o,"style")}const rn={data:{}};var an={create:t=>on(rn,t),update:on};var sn={create:function(t){const{elm:e,data:{classMap:n}}=t;if(N(n))return;const{classList:o}=e;for(const t in n)o.add(t)}};var ln={create:function(t){const{elm:e,data:{styleMap:n}}=t;if(N(n))return;const{style:o}=e;for(const t in n)o[t]=n[t]}};const cn={create:function(t){const{data:{context:e}}=t;if(N(e))return;const n=ht(t.elm,Lt);N(n)||m(n.context,e)}};
/**
@license
Copyright (c) 2015 Simon Friis Vindum.
This code may only be used under the MIT License found at
https://github.com/snabbdom/snabbdom/blob/master/LICENSE
Code distributed by Snabbdom as part of the Snabbdom project at
https://github.com/snabbdom/snabbdom/
*/function un(t){return void 0===t}function dn(t,e){return t.key===e.key&&t.sel===e.sel}function fn(t){return null!=t}function hn(t,e,n){const o={};let r,i,a;for(r=e;r<=n;++r)fn(a=t[r])&&void 0!==(i=a.key)&&(o[i]=r);return o}function mn(t,e,n,o,r){for(;o<=r;++o){const r=n[o];fn(r)&&(r.hook.create(r),r.hook.insert(r,t,e))}}function pn(t,e,n){let o,r,i,a,s=0,l=0,c=e.length-1,u=e[0],d=e[c],f=n.length-1,h=n[0],m=n[f];for(;s<=c&&l<=f;)fn(u)?fn(d)?fn(h)?fn(m)?dn(u,h)?(yn(u,h),u=e[++s],h=n[++l]):dn(d,m)?(yn(d,m),d=e[--c],m=n[--f]):dn(u,m)?(yn(u,m),m.hook.move(u,t,d.elm.nextSibling),u=e[++s],m=n[--f]):dn(d,h)?(yn(d,h),h.hook.move(d,t,u.elm),d=e[--c],h=n[++l]):(void 0===o&&(o=hn(e,s,c)),un(r=o[h.key])?(h.hook.create(h),h.hook.insert(h,t,u.elm),h=n[++l]):(fn(i=e[r])&&(i.sel!==h.sel?(h.hook.create(h),h.hook.insert(h,t,u.elm)):(yn(i,h),e[r]=void 0,h.hook.move(i,t,u.elm))),h=n[++l])):m=n[--f]:h=n[++l]:d=e[--c]:u=e[++s];if(s<=c||l<=f)if(s>c){const e=n[f+1];mn(t,a=fn(e)?e.elm:null,n,l,f)}else!function(t,e,n,o){for(;n<=o;++n){const o=e[n];fn(o)&&o.hook.remove(o,t)}}(t,e,s,c)}function gn(t,e,n){const{length:o}=n;if(0===e.length)return void mn(t,null,n,0,o);let r=null;for(let i=o-1;i>=0;i-=1){const o=n[i],a=e[i];o!==a&&(fn(a)?fn(o)?(yn(a,o),r=o.elm):a.hook.remove(a,t):fn(o)&&(o.hook.create(o),o.hook.insert(o,t,r),r=o.elm))}}function yn(t,e){t!==e&&(e.elm=t.elm,e.hook.update(t,e))}function vn(t){return m({configurable:!0,enumerable:!0,writable:!0},t)}function bn(t){return m({configurable:!0,enumerable:!0},t)}let wn=!1;function $n(){wn=!0}function Tn(){wn=!1}function En(t,e){return`The \`${t}\` ${e} is available only on elements that use the \`lwc:dom="manual"\` directive.`}function kn(t,e){const n=U(t,"textContent"),o=U(t,"nodeValue"),{appendChild:r,insertBefore:i,removeChild:a,replaceChild:s}=t;return{appendChild:vn({value(t){return this instanceof Element&&F(e.isPortal)&&ct.logError(En("appendChild","method"),this),r.call(this,t)}}),insertBefore:vn({value(t,n){return!wn&&this instanceof Element&&F(e.isPortal)&&ct.logError(En("insertBefore","method"),this),i.call(this,t,n)}}),removeChild:vn({value(t){return!wn&&this instanceof Element&&F(e.isPortal)&&ct.logError(En("removeChild","method"),this),a.call(this,t)}}),replaceChild:vn({value(t,n){return this instanceof Element&&F(e.isPortal)&&ct.logError(En("replaceChild","method"),this),s.call(this,t,n)}}),nodeValue:bn({get(){return o.get.call(this)},set(t){!wn&&this instanceof Element&&F(e.isPortal)&&ct.logError(En("nodeValue","property"),this),o.set.call(this,t)}}),textContent:bn({get(){return n.get.call(this)},set(t){this instanceof Element&&F(e.isPortal)&&ct.logError(En("textContent","property"),this),n.set.call(this,t)}})}}function Cn(t){t.$fromTemplate$=!0}function xn(t,e){w(t,function(t,e){const n=kn(t,e),o=U(t,"innerHTML"),r=U(t,"outerHTML");return m(n,{innerHTML:bn({get(){return o.get.call(this)},set(t){return F(e.isPortal)&&ct.logError(En("innerHTML","property"),this),o.set.call(this,t)}}),outerHTML:bn({get(){return r.get.call(this)},set(t){throw new TypeError("Invalid attempt to set outerHTML on Element.")}})}),n}(t,e))}function Rn(t,e){w(t,function(t,e){const n=t.querySelector,o=t.querySelectorAll,r=t.addEventListener,i=kn(t,e),a=U(t,"innerHTML"),s=U(t,"textContent");return m(i,{innerHTML:bn({get(){return a.get.call(this)},set(t){throw new TypeError("Invalid attempt to set innerHTML on ShadowRoot.")}}),textContent:bn({get(){return s.get.call(this)},set(t){throw new TypeError("Invalid attempt to set textContent on ShadowRoot.")}}),addEventListener:vn({value(e,n,o){return ct.invariant(!Po,`${Lo}.render() method has side effects on the state of ${K(t)} by adding an event listener for "${e}".`),N(o)||ct.logError("The `addEventListener` method in `LightningElement` does not support any options.",this.host),r.apply(this,arguments)}}),querySelector:vn({value(){const t=Vr(this);return ct.isFalse(Ho(t),`this.template.querySelector() cannot be called during the construction of the custom element for ${t} because no content has been rendered yet.`),n.apply(this,arguments)}}),querySelectorAll:vn({value(){const t=Vr(this);return ct.isFalse(Ho(t),`this.template.querySelectorAll() cannot be called during the construction of the custom element for ${t} because no content has been rendered yet.`),o.apply(this,arguments)}})}),A.call(b({cloneNode:0,getElementById:0,getSelection:0,elementsFromPoint:0,dispatchEvent:0}),t=>{const e=bn({get(){throw new Error(`Disallowed method "${t}" in ShadowRoot.`)}});i[t]=e}),i}(t,e))}function Sn(t,e){const n=function(t,e){const n=kn(t,e),o=t.addEventListener,r=U(t,"innerHTML"),i=U(t,"outerHTML"),a=U(t,"textContent");return m(n,{innerHTML:bn({get(){return r.get.call(this)},set(t){throw new TypeError("Invalid attempt to set innerHTML on HTMLElement.")}}),outerHTML:bn({get(){return i.get.call(this)},set(t){throw new TypeError("Invalid attempt to set outerHTML on HTMLElement.")}}),textContent:bn({get(){return a.get.call(this)},set(t){throw new TypeError("Invalid attempt to set textContent on HTMLElement.")}}),addEventListener:vn({value(t,e,n){return ct.invariant(!Po,`${Lo}.render() method has side effects on the state of ${K(this)} by adding an event listener for "${t}".`),N(n)||ct.logError("The `addEventListener` method in `LightningElement` does not support any options.",this),o.apply(this,arguments)}})})}(t,e),o=g(t);y(t,h(o,n))}function Mn(t){w(t,{tagName:bn({get(){throw new Error("Usage of property `tagName` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.")},configurable:!0,enumerable:!1})})}const An=()=>void 0;function On(t,e){t.$shadowToken$=e}function Pn(t,e){const{text:n}=e;t.text!==n&&($n(),e.elm.nodeValue=n,Tn())}function Ln(t,e,n){$n(),e.insertBefore(t.elm,n),Tn()}function In(t,e){$n(),e.removeChild(t.elm),Tn()}var Hn;function Nn(t){!function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isTrue(t.state===Tr.created,`${t} cannot be recycled.`);Ir(t),Or(t)}(Br(t.elm))}function jn(t,e){const{children:n,owner:o}=e,r=Wn(n)?pn:gn;Wr(o,o.owner,An,()=>{r(e.elm,t.children,n)},An)}function Dn(t){const e=Br(t.elm),{children:n}=t;e.aChildren=n,D(Dt)&&(!function(t,e){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.invariant(q(t.cmpSlots),"When doing manual allocation, there must be a cmpSlots object available.");const{cmpSlots:n}=t,o=t.cmpSlots=h(null);for(let t=0,n=e.length;t<n;t+=1){const n=e[t];if(j(n))continue;const{data:r}=n,i=r.attrs&&r.attrs.slot||"",a=o[i]=o[i]||[];n.key=`@${i}:${n.key}`,R.call(a,n)}if(F(t.isDirty)){const e=f(n);if(e.length!==f(o).length)return void Vo(t);for(let r=0,i=e.length;r<i;r+=1){const i=e[r];if(N(o[i])||n[i].length!==o[i].length)return void Vo(t);const a=n[i],s=o[i];for(let e=0,n=o[i].length;e<n;e+=1)if(a[e]!==s[e])return void Vo(t)}}}(e,n),t.children=Pt)}function Fn(t){const{elm:e,children:n}=t;for(let t=0;t<n.length;++t){const o=n[t];null!=o&&(o.hook.create(o),o.hook.insert(o,e,null))}}function Bn(t){const e=Br(t.elm);ct.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),ct.isTrue(T(t.children),"Invalid vnode for a custom element, it must have children defined."),function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);Or(t)}(e)}function qn(t){!function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isTrue(t.state===Tr.connected||t.state===Tr.disconnected,`${t} must have been connected.`);Sr(t)}(Br(t.elm))}!function(t){t.manual="manual"}(Hn||(Hn={}));const Vn=new WeakMap;function Wn(t){return Vn.has(t)}const zn=h(null),Kn=["wiring","locator","rendered","connected","disconnected"];function Un(t,e){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isTrue(T(e)&&e.length>0,"Optimize invokeServiceHook() to be invoked only when needed");const{component:n,data:o,def:r,context:i}=t;for(let t=0,a=e.length;t<a;++t)e[t].call(void 0,n,o,r,i)}const Yn=115,_n=118,Gn=103,Jn="http://www.w3.org/2000/svg",Qn=Symbol.iterator,Xn={create:t=>{t.elm=document.createTextNode(t.text),no(t),Cn(t.elm)},update:Pn,insert:Ln,move:Ln,remove:In},Zn={create:t=>{t.elm=document.createComment(t.text),no(t),Cn(t.elm)},update:Pn,insert:Ln,move:Ln,remove:In},to={create:t=>{const{data:e,sel:n,clonedElement:o}=t,{ns:r}=e;N(o)?t.elm=N(r)?document.createElement(n):document.createElementNS(r,n):t.elm=o,no(t),Cn(t.elm),function(t){const{owner:e}=t,n=t.elm;if(D(Dt)){const{data:{context:o}}=t,{shadowAttribute:r}=e.context;N(o)||N(o.lwc)||o.lwc.dom!==Hn.manual||function(t){t.$domManual$=!0}(n),On(n,r)}{const{data:{context:e}}=t;xn(n,{isPortal:!N(e)&&!N(e.lwc)&&e.lwc.dom===Hn.manual})}}(t),function(t){Bt.create(t),Ut.create(t),Qe.create(t),sn.create(t),ln.create(t),nn.create(t),an.create(t),cn.create(t)}(t)},update:(t,e)=>{!function(t,e){Ut.update(t,e),Qe.update(t,e),nn.update(t,e),an.update(t,e)}(t,e),jn(t,e)},insert:(t,e,n)=>{Ln(t,e,n),Fn(t)},move:(t,e,n)=>{Ln(t,e,n)},remove:(t,e)=>{In(t,e),function(t){const{children:e,elm:n}=t;for(let t=0,o=e.length;t<o;++t){const o=e[t];j(o)||o.hook.remove(o,n)}}(t)}},eo={create:t=>{const{sel:e}=t;t.elm=document.createElement(e),no(t),Cn(t.elm),function(t){const e=t.elm;if($.call(e,Lt))return;const{mode:n,ctor:o,owner:r}=t;if(mr(e,hr(o)),D(Dt)){const{shadowAttribute:t}=r.context;On(e,t)}Ar(e,o,{mode:n,owner:r});const i=Br(e);ct.isTrue(i&&"cmpRoot"in i,`${i} is not a vm.`),ct.isTrue(T(t.children),"Invalid vnode for a custom element, it must have children defined."),Sn(e,Ot)}(t),Dn(t),function(t){Bt.create(t),Ut.create(t),Qe.create(t),sn.create(t),ln.create(t),nn.create(t),an.create(t),cn.create(t)}(t)},update:(t,e)=>{!function(t,e){Ut.update(t,e),Qe.update(t,e),nn.update(t,e),an.update(t,e)}(t,e),Dn(e),jn(t,e),Bn(e)},insert:(t,e,n)=>{Ln(t,e,n),Fn(t),Nn(t)},move:(t,e,n)=>{Ln(t,e,n)},remove:(t,e)=>{In(t,e),qn(t)}};function no(t){t.elm.$shadowResolver$=t.owner.cmpRoot.$shadowResolver$}function oo(t,e,n){ct.isTrue(V(t),"h() 1st argument sel must be a string."),ct.isTrue(q(e),"h() 2nd argument data must be an object."),ct.isTrue(T(n),"h() 3rd argument children must be an array."),ct.isTrue("key"in e,` <${t}> "key" attribute is invalid or missing for ${Lo}. Key inside iterator is either undefined or null.`),ct.isFalse(e.className&&e.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),ct.isFalse(e.styleMap&&e.style,"vnode.data.styleMap and vnode.data.style ambiguous declaration."),e.style&&!V(e.style)&&ct.logError(`Invalid 'style' attribute passed to <${t}> is ignored. This attribute must be a string value.`,Lo.elm),A.call(n,t=>{null!=t&&ct.isTrue(t&&"sel"in t&&"data"in t&&"children"in t&&"text"in t&&"elm"in t&&"key"in t,`${t} is not a vnode.`)});const{key:o}=e;const r={sel:t,data:e,children:n,text:void 0,elm:void 0,key:o,hook:to,owner:Lo};return 3===t.length&&I.call(t,0)===Yn&&I.call(t,1)===_n&&I.call(t,2)===Gn&&function t(e){const{data:n,children:o,sel:r}=e;if(n.ns=Jn,T(o)&&"foreignObject"!==r)for(let e=0,n=o.length;e<n;++e){const n=o[e];null!=n&&n.hook===to&&t(n)}}(r),r}function ro(t,e,n,o){Nt(e)&&(e=jt(e)),ct.isTrue(V(t),"c() 1st argument sel must be a string."),ct.isTrue(B(e),"c() 2nd argument Ctor must be a function."),ct.isTrue(q(n),"c() 3nd argument data must be an object."),ct.isTrue(3===arguments.length||T(o),"c() 4nd argument data must be an array."),ct.isFalse(n.className&&n.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),ct.isFalse(n.styleMap&&n.style,"vnode.data.styleMap and vnode.data.style ambiguous declaration."),n.style&&!V(n.style)&&ct.logError(`Invalid 'style' attribute passed to <${t}> is ignored. This attribute must be a string value.`,Lo.elm),4===arguments.length&&A.call(o,t=>{null!=t&&ct.isTrue(t&&"sel"in t&&"data"in t&&"children"in t&&"text"in t&&"elm"in t&&"key"in t,`${t} is not a vnode.`)});const{key:r}=n;const i={sel:t,data:n,children:o=3===arguments.length?Pt:o,text:void 0,elm:void 0,key:r,hook:eo,ctor:e,owner:Lo,mode:"open"};return function(t){R.call(Lo.velements,t)}(i),i}function io(t){return{sel:void 0,data:Ot,children:void 0,text:t,elm:void 0,key:void 0,hook:Xn,owner:Lo}}function ao(t){if(j(Lo))throw new Error;const e=Lo;return function(n){jo(e,t,e.component,n)}}const so=new Map;let lo=0;function co(t){var e;return ct.isTrue(T(t),"sc() api can only work with arrays."),e=t,Vn.set(e,1),t}var uo=Object.freeze({h:oo,ti:function(t){const e=t>0&&!(D(t)||F(t));return e&&ct.logError(`Invalid tabindex value \`${K(t)}\` in template for ${Lo}. This attribute must be set to 0 or -1.`,Lo.elm),e?0:t},s:function(t,e,n,o){ct.isTrue(V(t),"s() 1st argument slotName must be a string."),ct.isTrue(q(e),"s() 2nd argument data must be an object."),ct.isTrue(T(n),"h() 3rd argument children must be an array."),N(o)||N(o[t])||0===o[t].length||(n=o[t]);const r=oo("slot",e,n);return Dt&&co(n),r},c:ro,i:function(t,e){const n=[];if(co(n),N(t)||null===t)return ct.logError(`Invalid template iteration for value "${K(t)}" in ${Lo}. It must be an Array or an iterable Object.`,Lo.elm),n;ct.isFalse(N(t[Qn]),`Invalid template iteration for value \`${K(t)}\` in ${Lo}. It must be an array-like object and not \`null\` nor \`undefined\`.`);const o=t[Qn]();ct.isTrue(o&&B(o.next),`Invalid iterator function for "${K(t)}" in ${Lo}.`);let r,i,a=o.next(),s=0,{value:l,done:c}=a;for(r=h(null);!1===c;){c=(a=o.next()).done;const t=e(l,s,0===s,c);T(t)?R.apply(n,t):R.call(n,t);{const e=T(t)?t:[t];A.call(e,t=>{if(!j(t)&&q(t)&&!N(t.sel)){const{key:e}=t;V(e)||W(e)?(1===r[e]&&N(i)&&(i=`Duplicated "key" attribute value for "<${t.sel}>" in ${Lo} for item number ${s}. A key with value "${t.key}" appears more than once in the iteration. Key values must be unique numbers or strings.`),r[e]=1):N(i)&&(i=`Invalid "key" attribute value in "<${t.sel}>" in ${Lo} for item number ${s}. Set a unique "key" value on all iterated child elements.`)}})}s+=1,l=a.value}return N(i)||ct.logError(i,Lo.elm),n},f:function(t){ct.isTrue(T(t),"flattening api can only work with arrays.");const e=t.length,n=[];co(n);for(let o=0;o<e;o+=1){const e=t[o];T(e)?R.apply(n,e):R.call(n,e)}return n},t:io,p:function(t){return{sel:"!",data:Ot,children:void 0,text:t,elm:void 0,key:void 0,hook:Zn,owner:Lo}},d:function(t){return null==t?null:io(t)},b:ao,fb:function(t){if(j(Lo))throw new Error;const e=Lo;return function(){return No(e,t,E.call(arguments))}},ll:function(t,e,n){if(j(Lo))throw new Error;const o=Lo,r=ao(t);return function(t){const{context:{locator:i}}=o;if(!N(i)){const{locator:t}=zn;t&&(i.resolved={target:e,host:i.id,targetContext:B(n)&&n(),hostContext:B(i.context)&&i.context()},Un(o,t))}r(t)}},k:function(t,e){switch(typeof e){case"number":case"string":return t+":"+e;case"object":ct.fail(`Invalid key value "${e}" in ${Lo}. Key must be a string or number.`)}},gid:function(t){return N(t)||""===t?(ct.logError(`Invalid id value "${t}". The id attribute must contain a non-empty string.`,Lo.elm),t):j(t)?null:`${t}-${Lo.idx}`},fid:function(t){return N(t)||""===t?(N(t)&&ct.logError('Undefined url value for "href" or "xlink:href" attribute. Expected a non-empty string.',Lo.elm),t):j(t)?null:/^#/.test(t)?`${t}-${Lo.idx}`:t},dc:function(t,e,n,o){if(ct.isTrue(V(t),"dc() 1st argument sel must be a string."),ct.isTrue(q(n),"dc() 3nd argument data must be an object."),ct.isTrue(3===arguments.length||T(o),"dc() 4nd argument data must be an array."),null==e)return null;if(!fr(e))throw new Error(`Invalid LWC Constructor ${K(e)} for custom element <${t}>.`);let r=so.get(e);return N(r)&&(r=lo++,so.set(e,r)),n.key=`dc:${r}:${n.key}`,ro(t,e,n,o)},sc:co});const fo=new Set;function ho(){return[]}fo.add(ho);const mo=h(null);function po(t){const e=document.createElement("style");return e.type="text/css",e.textContent=t,e}const go=document.head||document.body||document,yo=h(null);function vo(t,e,n,o,r){A.call(t,t=>{T(t)?vo(t,e,n,o,r):r(t(e,n,o))})}function bo(t,e,n,o){if(ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isTrue(T(e),"Invalid stylesheets."),Dt){return vo(e,`[${n}]`,`[${o}]`,!1,t=>{!function(t){if(N(yo[t])){yo[t]=!0;const e=po(t);go.appendChild(e)}}(t)}),null}{let t="";return vo(e,Y,Y,!0,e=>{t+=e}),function(t){const e=oo("style",{key:"style"},Pt);return e.clonedElement=t,e}(function(t){let e=mo[t];if(N(e)){e=document.createDocumentFragment();const n=po(t);e.appendChild(n),mo[t]=e}return e.cloneNode(!0).firstChild}(t))}}const wo=h(null);function $o(t,e){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isTrue(B(e),`evaluateTemplate() second argument must be an imported template instead of ${K(e)}`);const{component:n,context:o,cmpSlots:r,cmpTemplate:i}=t;if(e!==i){if(N(i)||Nr(t),a=e,!fo.has(a))throw new TypeError(`Invalid template returned by the render() method on ${t}. It must return an imported template (e.g.: \`import html from "./${t.def.name}.html"\`), instead, it has returned: ${K(e)}.`);t.cmpTemplate=e,o.tplCache=h(null),function(t){const{context:e,elm:n}=t,o=e.hostAttribute;N(o)||X.call(n,o),e.hostAttribute=e.shadowAttribute=void 0}(t);const{stylesheets:n,stylesheetTokens:r}=e;if(N(n)||0===n.length)o.styleVNode=null;else if(!N(r)){const{hostAttribute:e,shadowAttribute:i}=r;!function(t,e,n){const{context:o,elm:r}=t;J.call(r,e,""),o.hostAttribute=e,o.shadowAttribute=n}(t,e,i),o.styleVNode=bo(t,n,e,i)}(function(t,e){const{component:n}=t,{ids:o=[]}=e;A.call(o,e=>{e in n||ct.logError(`The template rendered by ${t} references \`this.${e}\`, which is not declared. Check for a typo in the template.`,t.elm)})})(t,e)}var a;ct.isTrue(q(o.tplCache),`vm.context.tplCache must be an object associated to ${i}.`),function(t,e){const{cmpSlots:n=wo}=t,{slots:o=Pt}=e;for(const e in n)ct.isTrue(T(n[e]),`Slots can only be set to an array, instead received ${K(n[e])} for slot "${e}" in ${t}.`),""!==e&&-1===x.call(o,e)&&ct.logError(`Ignoring unknown provided slot name "${e}" in ${t}. Check for a typo on the slot attribute.`,t.elm)}(t,e),t.velements=[];const s=e.call(void 0,uo,n,r,o.tplCache),{styleVNode:l}=o;return j(l)||C.call(s,l),ct.invariant(T(s),"Compiler should produce html functions that always return an array."),s}var To;!function(t){t.REHYDRATE="lwc-rehydrate",t.HYDRATE="lwc-hydrate"}(To||(To={}));const Eo="undefined"!=typeof performance&&"function"==typeof performance.mark&&"function"==typeof performance.clearMarks&&"function"==typeof performance.measure&&"function"==typeof performance.clearMeasures;function ko(t,e){return`<${L.call(tt.call(e.elm))} (${e.idx})> - ${t}`}function Co(t){performance.mark(t)}function xo(t,e){performance.measure(t,e),performance.clearMarks(e),performance.clearMarks(t)}function Ro(){}const So=Eo?function(t,e){Co(ko(t,e))}:Ro,Mo=Eo?function(t,e){const n=ko(t,e);xo(n,n)}:Ro,Ao=Eo?function(t,e){Co(N(e)?t:ko(t,e))}:Ro,Oo=Eo?function(t,e){xo(t,N(e)?t:ko(t,e))}:Ro;let Po=!1,Lo=null,Io=null;function Ho(t){return ct.isTrue(t&&"cmpProps"in t,`${t} is not a vm.`),Io===t}function No(t,e,n){const{component:o,callHook:r,context:i,owner:a}=t;let s;return Wr(t,a,()=>{},()=>{s=r(o,e,n)},()=>{}),s}function jo(t,e,n,o){const{callHook:r,owner:i,context:a}=t;Wr(t,i,()=>{},()=>{ct.isTrue(B(e),`Invalid event handler for event '${o.type}' on ${t}.`),r(n,e,[o])},()=>{})}const Do=new Map;function Fo(t,e){if(ct.isTrue(t&&"cmpProps"in t,`${t} is not a vm.`),function(t,e){const n=Io;let o;ct.isTrue(t&&"cmpProps"in t,`${t} is not a vm.`),So("constructor",t),Io=t;try{const r=new e;if(Io.component!==r)throw new TypeError("Invalid component constructor, the class should extend LightningElement.")}catch(t){o=Object(t)}finally{if(Mo("constructor",t),Io=n,!N(o))throw o.wcStack=Dr(t.elm),o}}(t,e),N(t.component))throw new ReferenceError(`Invalid construction for ${e}, you must extend LightningElement.`)}function Bo(t){return new je(()=>{ct.invariant(!Po,`Mutating property is not allowed during the rendering life-cycle of ${Lo}.`);const{isDirty:e}=t;F(e)&&(Vo(t),function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);t.isScheduled||(t.isScheduled=!0,0===Pr.length&&Ht(Lr),R.call(Pr,t))}(t))})}function qo(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.invariant(t.isDirty,`${t} is not dirty.`),t.tro.reset();const e=function(t){const{def:{render:e},callHook:n,component:o,context:r,owner:i}=t,a=Po,s=Lo;let l;return Po=!0,Lo=t,Wr(t,i,()=>{So("render",t),Po=!0,Lo=t},()=>{t.tro.observe(()=>{const r=n(o,e);l=$o(t,r)})},()=>{Mo("render",t),Po=a,Lo=s}),l||[]}(t);return t.isDirty=!1,t.isScheduled=!1,ct.invariant(T(e),`${t}.render() should always return an array of vnodes instead of ${e}`),e}function Vo(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isFalse(t.isDirty,`markComponentAsDirty() for ${t} should not be called when the component is already dirty.`),ct.isFalse(Po,`markComponentAsDirty() for ${t} cannot be called during rendering of ${Lo}.`),t.isDirty=!0}const Wo=new WeakMap;function zo(t,e){if(ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),!B(e))throw new TypeError;let n=Wo.get(e);return N(n)&&(n=function(n){jo(t,e,void 0,n)},Wo.set(e,n)),n}function Ko(t){const e=qr(t);return`<${L.call(tt.call(e.elm))}>`}function Uo(t){return O.call(t,(t,e)=>(t[e]=function(t){return{get(){const e=qr(this);return ct.isTrue(e&&"cmpRoot"in e,`${e} is not a valid vm.`),Ne(this,t),e.cmpTrack[t]},set(e){const n=qr(this);ct.isTrue(n&&"cmpRoot"in n,`${n} is not a valid vm.`),e!==n.cmpTrack[t]&&(n.cmpTrack[t]=e,F(n.isDirty)&&He(this,t))},enumerable:!0,configurable:!0}}(e),t),{})}const Yo=v(ShadowRoot.prototype,"host").get,_o=v(ShadowRoot.prototype,"innerHTML").set,Go="EventTarget"in window?EventTarget.prototype.dispatchEvent:Node.prototype.dispatchEvent,Jo=Event;function Qo(t){return qr(t).elm}function Xo(){if(j(Io))throw new ReferenceError;ct.isTrue("cmpProps"in Io,`${Io} is not a vm.`),ct.invariant(Io.elm instanceof HTMLElement,`Component creation requires a DOM element to be associated to ${Io}.`);const t=Io,{elm:e,mode:n,def:{ctor:o}}=t,r=this;if(t.component=r,t.tro=Bo(t),1===arguments.length){const{callHook:e,setHook:n,getHook:o}=arguments[0];t.callHook=e,t.setHook=n,t.getHook=o}const i={mode:n,delegatesFocus:!!o.delegatesFocus},a=e.attachShadow(i);return pt(r,Lt,t),ft(e,Lt,t),ft(a,Lt,t),t.cmpRoot=a,Mn(r),Rn(a,Ot),this}Xo.prototype={constructor:Xo,dispatchEvent(t){const e=Qo(this),n=qr(this);{if(0===arguments.length)throw new Error(`Failed to execute 'dispatchEvent' on ${Ko(this)}: 1 argument required, but only 0 present.`);if(!(t instanceof Jo))throw new Error(`Failed to execute 'dispatchEvent' on ${Ko(this)}: parameter 1 is not of type 'Event'.`);const{type:o}=t;ct.isFalse(Ho(n),`this.dispatchEvent() should not be called during the construction of the custom element for ${Ko(this)} because no one is listening for the event "${o}" just yet.`),/^[a-z][a-z0-9_]*$/.test(o)||ct.logError(`Invalid event type "${o}" dispatched in element ${Ko(this)}. Event name must ${["1) Start with a lowercase letter","2) Contain only lowercase letters, numbers, and underscores"].join(" ")}`,e)}return Go.call(e,t)},addEventListener(t,e,n){const o=qr(this);ct.isTrue(o&&"cmpRoot"in o,`${o} is not a vm.`),ct.invariant(!Po,`${Lo}.render() method has side effects on the state of ${o} by adding an event listener for "${t}".`),ct.invariant(B(e),`Invalid second argument for this.addEventListener() in ${o} for event "${t}". Expected an EventListener but received ${e}.`);const r=zo(o,e);o.elm.addEventListener(t,r,n)},removeEventListener(t,e,n){const o=qr(this);ct.isTrue(o&&"cmpRoot"in o,`${o} is not a vm.`);const r=zo(o,e);o.elm.removeEventListener(t,r,n)},setAttributeNS(t,e,n){const o=Qo(this);ct.isFalse(Ho(qr(this)),`Failed to construct '${Ko(this)}': The result must not have attributes.`),St(o,e),o.setAttributeNS.apply(o,arguments),Rt()},removeAttributeNS(t,e){const n=Qo(this);St(n,e),n.removeAttributeNS.apply(n,arguments),Rt()},removeAttribute(t){const e=Qo(this);St(e,t),e.removeAttribute.apply(e,arguments),Rt()},setAttribute(t,e){const n=Qo(this);ct.isFalse(Ho(qr(this)),`Failed to construct '${Ko(this)}': The result must not have attributes.`),St(n,t),n.setAttribute.apply(n,arguments),Rt()},getAttribute(t){const e=Qo(this);St(e,t);const n=e.getAttribute.apply(e,arguments);return Rt(),n},getAttributeNS(t,e){const n=Qo(this);St(n,e);const o=n.getAttributeNS.apply(n,arguments);return Rt(),o},getBoundingClientRect(){const t=Qo(this);{const t=qr(this);ct.isFalse(Ho(t),`this.getBoundingClientRect() should not be called during the construction of the custom element for ${Ko(this)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`)}return t.getBoundingClientRect()},querySelector(t){const e=qr(this);ct.isFalse(Ho(e),`this.querySelector() cannot be called during the construction of the custom element for ${Ko(this)} because no children has been added to this element yet.`);const{elm:n}=e;return n.querySelector(t)},querySelectorAll(t){const e=qr(this);ct.isFalse(Ho(e),`this.querySelectorAll() cannot be called during the construction of the custom element for ${Ko(this)} because no children has been added to this element yet.`);const{elm:n}=e;return n.querySelectorAll(t)},getElementsByTagName(t){const e=qr(this);ct.isFalse(Ho(e),`this.getElementsByTagName() cannot be called during the construction of the custom element for ${Ko(this)} because no children has been added to this element yet.`);const{elm:n}=e;return n.getElementsByTagName(t)},getElementsByClassName(t){const e=qr(this);ct.isFalse(Ho(e),`this.getElementsByClassName() cannot be called during the construction of the custom element for ${Ko(this)} because no children has been added to this element yet.`);const{elm:n}=e;return n.getElementsByClassName(t)},get classList(){{const t=qr(this);ct.isFalse(Ho(t),`Failed to construct ${t}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`)}return Qo(this).classList},get template(){const t=qr(this);return ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),t.cmpRoot},get shadowRoot(){return null},render(){return qr(this).def.template},toString(){const t=qr(this);return ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),`[object ${t.def.name}]`}};const Zo=O.call(b(Yt),(t,e)=>(t[e]=function(t,e){const{get:n,set:o,enumerable:r,configurable:i}=e;if(!B(n))throw ct.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${t} definition. Missing the standard getter.`),new TypeError;if(!B(o))throw ct.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${t} definition. Missing the standard setter.`),new TypeError;return{enumerable:r,configurable:i,get(){const e=qr(this);if(ct.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),!Ho(e))return Ne(this,t),n.call(e.elm);{const n=e.elm.constructor.name;ct.logError(`\`${n}\` constructor can't read the value of property \`${t}\` because the owner component hasn't set the value yet. Instead, use the \`${n}\` constructor to set a default value for the property.`,e.elm)}},set(e){const n=qr(this);return ct.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),ct.invariant(!Po,`${Lo}.render() method has side effects on the state of ${n}.${t}`),ct.isFalse(Ho(n),`Failed to construct '${Ko(this)}': The result must not have attributes.`),ct.invariant(!q(e)||j(e),`Invalid value "${e}" for "${t}" of ${n}. Value cannot be an object, must be a primitive value.`),e!==n.cmpProps[t]&&(n.cmpProps[t]=e,F(n.isDirty)&&He(this,t)),o.call(n.elm,e)}}}(e,Yt[e]),t),h(null));var tr;w(Xo.prototype,Zo),tr=Xo.prototype,w(tr,function(t){const e={};return A.call(b(bt),n=>{n in t||(e[n]=bn({get(){const{error:t,attribute:e}=bt[n],o=[];o.push(`Accessing the global HTML property "${n}" is disabled.`),t?o.push(t):e&&o.push(`Instead access it via \`this.getAttribute("${e}")\`.`),ct.logError(o.join("\n"),qr(this).elm)},set(){const{readOnly:t}=bt[n];t&&ct.logError(`The global HTML property \`${n}\` is read-only.`)}}))}),e}(tr)),u(Xo),d(Xo.prototype);const er=Xo;function nr(t,e,n){if(1===arguments.length)return Fe.getProxy(t);if(3!==arguments.length&&ct.fail("@track decorator can only be used with one argument to return a trackable object, or as a decorator function."),!N(n)){const{get:t,set:e,configurable:o,writable:r}=n;ct.isTrue(!t&&!e,"Compiler Error: A @track decorator can only be applied to a public field."),ct.isTrue(!1!==o,"Compiler Error: A @track decorator can only be applied to a configurable property."),ct.isTrue(!1!==r,"Compiler Error: A @track decorator can only be applied to a writable property.")}return or(t,e,!!N(n)||!0===n.enumerable)}function or(t,e,n){return{get(){const t=qr(this);return ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),Ne(this,e),t.cmpTrack[e]},set(t){const n=qr(this);ct.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),ct.invariant(!Po,`${Lo}.render() method has side effects on the state of ${n}.${String(e)}`);const o=Fe.getProxy(t);o!==n.cmpTrack[e]&&(n.cmpTrack[e]=o,F(n.isDirty)&&He(this,e))},enumerable:n,configurable:!0}}function rr(t,e,n){if(!N(n)){const{get:t,set:e,configurable:o,writable:r}=n;ct.isTrue(!t&&!e,"Compiler Error: A @wire decorator can only be applied to a public field."),ct.isTrue(!1!==o,"Compiler Error: A @wire decorator can only be applied to a configurable property."),ct.isTrue(!1!==r,"Compiler Error: A @wire decorator can only be applied to a writable property.")}return or(0,e,!q(n)||!0===n.enumerable)}function ir(t,e){const n=arguments.length;if(n>0&&n<3)return rr;throw ct.fail("@wire(adapter, config?) may only be used as a decorator."),new TypeError}function ar(t,e,n){3!==arguments.length&&ct.fail("@api decorator can only be used as a decorator function."),ct.invariant(!n||B(n.get)||B(n.set),`Invalid property ${K(e)} definition in ${t}, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`),q(n)&&B(n.set)&&ct.isTrue(q(n)&&B(n.get),`Missing getter for property ${K(e)} decorated with @api in ${t}. You cannot have a setter without the corresponding getter.`);const o=cr(t);return q(n)&&(B(n.get)||B(n.set))?(o.props[e].config=B(n.set)?3:1,function(t,e,n){const{get:o,set:r,enumerable:i}=n;if(!B(o))throw ct.fail(`Invalid attempt to create public property descriptor ${K(e)} in ${t}. It is missing the getter declaration with @api get ${K(e)}() {} syntax.`),new TypeError;return{get(){{const t=qr(this);ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`)}return o.call(this)},set(t){const n=qr(this);ct.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),ct.invariant(!Po,`${Lo}.render() method has side effects on the state of ${n}.${K(e)}`),r?r.call(this,t):ct.fail(`Invalid attempt to set a new value for property ${K(e)} of ${n} that does not has a setter decorated with @api.`)},enumerable:i}}(t,e,n)):(o.props[e].config=0,function(t,e,n){return{get(){const t=qr(this);if(ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),!Ho(t))return Ne(this,e),t.cmpProps[e];{const n=t.elm.constructor.name;ct.logError(`\`${n}\` constructor can’t read the value of property \`${K(e)}\` because the owner component hasn’t set the value yet. Instead, use the \`${n}\` constructor to set a default value for the property.`,t.elm)}},set(t){const n=qr(this);ct.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),ct.invariant(!Po,`${Lo}.render() method has side effects on the state of ${n}.${K(e)}`),n.cmpProps[e]=t,F(n.isDirty)&&He(this,e)},enumerable:!!N(n)||n.enumerable}}(0,e,n))}function sr(t,e){if(!B(t)||null==e)throw new TypeError;const n=b(e),o=t.prototype;for(let r=0,i=n.length;r<i;r+=1){const i=n[r],a=e[i];if(!B(a))throw new TypeError;const s=a(t,i,v(o,i));N(s)||p(o,i,s)}return t}const lr=new Map;function cr(t){return lr.get(t)}const ur=new WeakMap;function dr(t,e,n){{const e=t.name;ct.isTrue(t.constructor,`Missing ${e}.constructor, ${e} should have a "constructor" property.`)}const{name:o}=e;let{template:r}=e;const i=cr(t);let a,s,l={},c={},d={};N(i)||(l=i.props,c=i.methods,a=i.wire,d=i.track,s=i.fields);const f=t.prototype;let{connectedCallback:p,disconnectedCallback:y,renderedCallback:v,errorCallback:$,render:T}=f;const E=function(t,e){let n=g(t);if(j(n))throw new ReferenceError(`Invalid prototype chain for ${e}, you must extend LightningElement.`);if(Nt(n)){const t=jt(n);if(j(t))throw new ReferenceError(`Circular module dependency for ${e}, must resolve to a constructor that extends LightningElement.`);n=t===n?er:t}return n}(t,n),k=E!==er?hr(E,n):null,C=Ue(j(k)?Ye:k.bridge,b(l),b(c));j(k)||(l=m(h(null),k.props,l),c=m(h(null),k.methods,c),a=k.wire||a?m(h(null),k.wire,a):void 0,d=m(h(null),k.track,d),p=p||k.connectedCallback,y=y||k.disconnectedCallback,v=v||k.renderedCallback,$=$||k.errorCallback,T=T||k.render,r=r||k.template),l=m(h(null),pr,l),N(s)||w(f,Uo(s)),N(r)&&(r=ho);const x={ctor:t,name:o,wire:a,track:d,props:l,methods:c,bridge:C,template:r,connectedCallback:p,disconnectedCallback:y,renderedCallback:v,errorCallback:$,render:T};return u(t.prototype),x}function fr(t){if(!B(t))return!1;if(t.prototype instanceof er)return!0;let e=t;do{if(Nt(e)){const t=jt(e);if(t===e)return!0;e=t}if(e===er)return!0}while(!j(e)&&(e=g(e)));return!1}function hr(t,e){let n=ur.get(t);if(N(n)){if(!fr(t))throw new TypeError(`${t} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);let o=function(t){return Do.get(t)}(t);N(o)&&(o={template:void 0,name:t.name}),n=dr(t,o,e||t.name),ur.set(t,n)}return n}function mr(t,e){y(t,e.bridge.prototype)}const pr=O.call(b(Yt),(t,e)=>{const n=kt(e);return t[e]={config:3,type:"any",attr:n},t},h(null)),{appendChild:gr,insertBefore:yr,removeChild:vr,replaceChild:br}=Node.prototype,wr=v(Node.prototype,"parentNode").get,$r=$.call(Node.prototype,"parentElement")?v(Node.prototype,"parentElement").get:v(HTMLElement.prototype,"parentElement").get;var Tr;!function(t){t[t.created=0]="created",t[t.connected=1]="connected",t[t.disconnected=2]="disconnected"}(Tr||(Tr={}));let Er=0;function kr(t,e,n=[]){return e.apply(t,n)}function Cr(t,e,n){t[e]=n}function xr(t,e){return t[e]}function Rr(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),Ir(t),Or(t)}function Sr(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{state:e}=t;if(e!==Tr.disconnected){const{tro:e}=t;e.reset(),function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isTrue(t.state!==Tr.disconnected,`${t} must be inserted.`);F(t.isDirty)&&(t.isDirty=!0);t.state=Tr.disconnected;const{disconnected:e}=zn;e&&Un(t,e);const{disconnectedCallback:n}=t.def;N(n)||(So("disconnectedCallback",t),No(t,n),Mo("disconnectedCallback",t))}(t),Hr(t),function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{aChildren:e}=t;!function t(e){for(let n=0,o=e.length;n<o;n+=1){const o=e[n];j(o)||!T(o.children)||N(o.elm)||(N(o.ctor)?t(o.children):Sr(Br(o.elm)))}}(e)}(t)}}function Mr(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),Sr(t)}function Ar(t,e,n){ct.invariant(t instanceof HTMLElement,`VM creation requires a DOM element instead of ${t}.`);const o=hr(e),{isRoot:r,mode:i,owner:a}=n,s={idx:Er+=1,state:Tr.created,isScheduled:!1,isDirty:!0,isRoot:D(r),mode:i,def:o,owner:a,elm:t,data:Ot,context:h(null),cmpProps:h(null),cmpTrack:h(null),cmpSlots:Dt?h(null):void 0,callHook:kr,setHook:Cr,getHook:xr,children:Pt,aChildren:Pt,velements:Pt,cmpTemplate:void 0,component:void 0,cmpRoot:void 0,tro:void 0,toString:()=>`[object:vm ${o.name} (${s.idx})]`};Fo(s,e),function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{def:{wire:e}}=t;if(e){const{wiring:e}=zn;e&&Un(t,e)}}(s)}function Or(t){if(ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),ct.isTrue(t.elm instanceof HTMLElement,`rehydration can only happen after ${t} was patched the first time.`),D(t.isDirty)){!function(t,e){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{cmpRoot:n,children:o}=t;if(t.children=e,(e.length>0||o.length>0)&&o!==e){const r=Wn(e)?pn:gn;Wr(t,t,()=>{So("patch",t)},()=>{r(n,o,e)},()=>{Mo("patch",t)})}t.state===Tr.connected&&function(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{rendered:e}=zn;e&&Un(t,e);const{renderedCallback:n}=t.def;N(n)||(So("renderedCallback",t),No(t,n),Mo("renderedCallback",t))}(t)}(t,qo(t))}}let Pr=[];function Lr(){Ao(To.REHYDRATE),ct.invariant(Pr.length,`If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${Pr}.`);const t=Pr.sort((t,e)=>t.idx-e.idx);Pr=[];for(let e=0,n=t.length;e<n;e+=1){const o=t[e];try{Or(o)}catch(o){throw e+1<n&&(0===Pr.length&&Ht(Lr),C.apply(Pr,E.call(t,e+1))),Oo(To.REHYDRATE),o}}Oo(To.REHYDRATE)}function Ir(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{state:e}=t;if(e===Tr.connected)return;t.state=Tr.connected;const{connected:n}=zn;n&&Un(t,n);const{connectedCallback:o}=t.def;N(o)||(So("connectedCallback",t),No(t,o),Mo("connectedCallback",t))}function Hr(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{velements:e}=t;for(let t=e.length-1;t>=0;t-=1){const n=e[t].elm;if(!N(n)){Sr(Br(n))}}}function Nr(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),t.children=Pt,_o.call(t.cmpRoot,""),Hr(t)}function jr(t){ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`);const{elm:e}=t;return function(t){let e,n=t;for(;!j(n);){if(!N(e=ht(n,Lt))&&!N(e.def.errorCallback))return e;n=Fr(n)}}(e)}function Dr(t){const e=[];let n=t;do{if(!N(ht(n,Lt))){const t=tt.call(n),o=n.getAttribute("is");R.call(e,`<${L.call(t)}${o?' is="${is}':""}>`)}n=Fr(n)}while(!j(n));return e.reverse().join("\n\t")}function Fr(t){const e=$r.call(t);return j(e)?function(t){ct.isTrue(j($r.call(t)),`getHostElement should only be called if the parent element of ${t} is null`);const e=wr.call(t);return e instanceof ShadowRoot?Yo.call(e):null}(t):e}function Br(t){{const e=ht(t,Lt);ct.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`)}return ht(t,Lt)}function qr(t){{const e=gt(t,Lt);ct.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`)}return gt(t,Lt)}function Vr(t){{const e=ht(t,Lt);ct.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`)}return ht(t,Lt)}function Wr(t,e,n,o,r){let i;ct.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),n();try{o()}catch(t){i=Object(t)}finally{if(r(),!N(i)){i.wcStack=i.wcStack||Dr(t.elm);const n=j(e)?void 0:jr(e);if(N(n))throw i;Nr(t),So("errorCallback",n),No(n,n.def.errorCallback,[i,i.wcStack]),Mo("errorCallback",n)}}}const zr=dt("connecting"),Kr=dt("disconnecting");function Ur(t,e){ct.isTrue(t,"callNodeSlot() should not be called for a non-object");const n=ht(t,e);return N(n)||n(),t}m(Node.prototype,{appendChild(t){return Ur(gr.call(this,t),zr)},insertBefore(t,e){return Ur(yr.call(this,t,e),zr)},removeChild(t){return Ur(vr.call(this,t),Kr)},replaceChild(t,e){const n=br.call(this,t,e);return Ur(n,Kr),Ur(t,zr),n}}),e.LightningElement=er,e.api=ar,e.buildCustomElementConstructor=function(t,e){var n;const{props:o,bridge:r}=hr(t),i={mode:"open",isRoot:!0,owner:null};if(q(e)&&!j(e)){const{mode:t}=e;"closed"===t&&(i.mode=t)}return(n=class extends r{constructor(){super(),Ar(this,t,i),Sn(this,Ot)}connectedCallback(){Rr(Br(this))}disconnectedCallback(){Mr(Br(this))}attributeChangedCallback(t,e,n){if(e===n)return;const r=function(t){return N(wt[t])&&(wt[t]=P.call(t,Tt,t=>t[1].toUpperCase())),wt[t]}(t);N(o[r])||function(t,e){return t!==xt||e!==Ct}(this,t)&&(this[r]=n)}}).observedAttributes=S.call(b(o),t=>o[t].attr),n},e.createElement=function(t,e){if(!q(e)||j(e))throw new TypeError(`"createElement" function expects an object as second parameter but received "${K(e)}".`);let n=e.is;if(!B(n))throw new TypeError('"createElement" function expects a "is" option with a valid component constructor.');const o="closed"!==e.mode?"open":"closed",r=document.createElement(t);if(!N(ht(r,Lt)))return r;Nt(n)&&(n=jt(n));const i=hr(n);return mr(r,i),Sn(r,Ot),Ar(r,n,{mode:o,isRoot:!0,owner:null}),ft(r,zr,()=>{const t=Br(r);Ao(To.HYDRATE,t),t.state===Tr.connected&&Mr(t),Rr(t),Oo(To.HYDRATE,t)}),ft(r,Kr,()=>{Mr(Br(r))}),r},e.decorate=sr,e.getComponentConstructor=function(t){let e=null;if(t instanceof HTMLElement){const n=ht(t,Lt);N(n)||(e=n.def.ctor)}return e},e.getComponentDef=hr,e.isComponentConstructor=fr,e.isNodeFromTemplate=function(t){return!F(t instanceof Node)&&(!(t instanceof ShadowRoot)&&((!Dt||!N(t.$shadowResolver$))&&t.getRootNode()instanceof ShadowRoot))},e.readonly=function(t){return 1!==arguments.length&&ct.fail("@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value."),Fe.getReadOnlyProxy(t)},e.register=function(t){ct.isTrue(q(t),`Invalid service declaration, ${t}: service must be an object`);for(let e=0;e<Kn.length;++e){const n=Kn[e];if(n in t){let e=zn[n];N(e)&&(zn[n]=e=[]),R.call(e,t[n])}}},e.registerComponent=function(t,{name:e,tmpl:n}){return Do.set(t,{name:e,template:n}),t},e.registerDecorators=function(t,e){const n=h(null),o=function(t,e){if(N(e)||0===b(e).length)return Ot;return b(e).reduce((t,n)=>{const o=kt(n);return t[n]=m({config:0,type:"any",attr:o},e[n]),t},h(null))}(0,e.publicProps),r=function(t,e){if(N(e)||0===e.length)return Ot;return e.reduce((e,n)=>(ct.isTrue(B(t.prototype[n]),`Component "${t.name}" should have a method \`${n}\` instead of ${t.prototype[n]}.`),e[n]=t.prototype[n],e),h(null))}(t,e.publicMethods),i=function(t,e){if(N(e)||0===b(e).length)return;return m(h(null),e)}(0,e.wire),a=function(t,e){if(N(e)||0===b(e).length)return Ot;return m(h(null),e)}(0,e.track),s=e.fields;lr.set(t,{props:o,methods:r,wire:i,track:a,fields:s});for(const t in o)n[t]=ar;if(i)for(const t in i){const e=i[t];e.method||(n[t]=ir(e.adapter,e.params))}if(a)for(const t in a)n[t]=nr;return sr(t,n),t},e.registerTemplate=function(t){return fo.add(t),t},e.sanitizeAttribute=function(t,e,n,o){return o},e.track=nr,e.unwrap=function(t){const e=Fe.unwrapProxy(t);return e!==t?De(e):t},e.wire=ir}).call(this,n(3))}]]);